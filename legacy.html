<!DOCTYPE html>

<html>
  <head>
    <title>linemapy</title>
    <meta charset="UTF-8" />
    <style type="text/css">
      html {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      body {
        font-family: monospace;
        font-size: 10px;
        -webkit-font-smoothing: none;

        margin: 0;
        padding: 0;
        height: 100%;

        cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANCAYAAAB7AEQGAAAAT0lEQVQYlYXRMQ7AMAgDQNvK/7/sDk2rihriCdANCAjAtokhAgCSPiLbI9RTTFDfpoOqgwR/KMGIKuTd9xcgiZWGNauCdH2dwLvTXrT93wUacysWyuC4MQAAAABJRU5ErkJggg=='), auto;
      }
      button {
        font-family: monospace;
        font-size: 10px;
        -webkit-font-smoothing: none;

        margin-left: 1px;
        margin-right: 1px;
        margin-top: 1px;
        margin-bottom: 1px;
        padding-left: 2px;
        padding-right: 2px;
        padding-top: 1px;
        padding-bottom: 1px;

        width: 100px;

        background-color: rgb(196, 196, 196);

        border-style: solid;
        border-color: rgb(0, 0, 0);
        color: rgb(0, 0, 0);
      }
      button:hover {
        background-color: rgb(255, 255, 255);
      }
      button:active {
        background-color: rgb(128, 128, 128);
      }
    </style>
    <script type="text/javascript">
      //utilities
      function removehtml(id) {
        var child = document.getElementById(id)
        if (child == null) return
        child.parentNode.removeChild(child)
      }
      function sethtml(id, html) {
        var child = document.getElementById(id)
        if (child == null) return
        child.innerHTML = html
      }
      function appendhtml(id, html) {
        var child = document.getElementById(id)
        if (child == null) return
        child.innerHTML += html
      }
      Math.seed = 6
      Math.seededrandom = function (max, min) {
        max = max || 1
        min = min || 0

        Math.seed = (Math.seed * 9301 + 49297) % 233280
        var rnd = Math.seed / 233280

        return min + rnd * (max - min)
      }
      function lineintersection(x1, y1, x2, y2, x3, y3, x4, y4) {
        var a1, a2, b1, b2, c1, c2
        var r1, r2, r3, r4
        var denom, offset, num

        a1 = y2 - y1
        b1 = x1 - x2
        c1 = x2 * y1 - x1 * y2

        r3 = a1 * x3 + b1 * y3 + c1
        r4 = a1 * x4 + b1 * y4 + c1

        if (r3 != 0 && r4 != 0 && r3 * r4 >= 0) return false

        a2 = y4 - y3
        b2 = x3 - x4
        c2 = x4 * y3 - x3 * y4

        r1 = a2 * x1 + b2 * y1 + c2
        r2 = a2 * x2 + b2 * y2 + c2

        if (r1 != 0 && r2 != 0 && r1 * r2 >= 0) return false

        denom = a1 * b2 - a2 * b1

        if (denom == 0) return false
        return true
      }
      function lineintersectionpoint(x1, y1, x2, y2, x3, y3, x4, y4) {
        var x, y

        var a1, a2, b1, b2, c1, c2
        var r1, r2, r3, r4
        var denom, offset, num

        a1 = y2 - y1
        b1 = x1 - x2
        c1 = x2 * y1 - x1 * y2

        r3 = a1 * x3 + b1 * y3 + c1
        r4 = a1 * x4 + b1 * y4 + c1

        if (r3 != 0 && r4 != 0 && r3 * r4 >= 0) return null

        a2 = y4 - y3
        b2 = x3 - x4
        c2 = x4 * y3 - x3 * y4

        r1 = a2 * x1 + b2 * y1 + c2
        r2 = a2 * x2 + b2 * y2 + c2

        if (r1 != 0 && r2 != 0 && r1 * r2 >= 0) return null

        denom = a1 * b2 - a2 * b1
        if (denom == 0) return null

        if (denom < 0) offset = -denom / 2
        else offset = denom / 2

        num = b1 * c2 - b2 * c1
        if (num < 0) x = (num - offset) / denom
        else x = (num + offset) / denom

        num = a2 * c1 - a1 * c2
        if (num < 0) y = (num - offset) / denom
        else y = (num + offset) / denom

        return new Array(x, y)
      }
      //!utilities

      //datapack objects
      function vector(x, y) {
        this.x = x
        this.y = y
        this.index = 0
      }
      function navpoint(t, f, s, sec) {
        this.type = t
        this.links = new Array()
        this.index = 0
        this.sector = sec

        if (t == 0) {
          this.first = f
          this.second = s

          var nx0 = f.end.y - f.start.y
          var ny0 = -(f.end.x - f.start.x)
          var nm = Math.sqrt(nx0 * nx0 + ny0 * ny0)
          nx0 /= nm
          ny0 /= nm

          var nx1 = s.end.y - s.start.y
          var ny1 = -(s.end.x - s.start.x)
          nm = Math.sqrt(nx1 * nx1 + ny1 * ny1)
          nx1 /= nm
          ny1 /= nm

          this.x = f.end.x + (nx0 + nx1) * 0.25
          this.y = f.end.y + (ny0 + ny1) * 0.25
        } else {
          this.x = f
          this.y = s
        }
      }
      function entity(x, y) {
        this.x = x
        this.y = y
        this.reference = 0
        this.angle = 0
      }
      function linedef(s, e) {
        this.start = s
        this.end = e
        this.utex = 0
        this.mtex = 1
        this.ltex = 0
        this.index = 0
        this.plus = null
        this.minus = null
      }
      function subsector(vs) {
        this.vecs = vs
        this.index = 0
      }
      function sector(sbs, ls, ps) {
        this.type = 0
        this.fheight = 0
        this.cheight = 10
        this.subs = sbs
        this.lines = ls
        this.portals = ps
        this.ftex = 2
        this.ctex = 2
        this.poly = new Array()
        for (var i = 0; i < ls.length; i++) this.poly.push(ls[i].start)
        for (var i = 0; i < ps.length; i++) this.poly.push(ps[i].start)
      }
      //!datapack objects

      //datapack functions
      function vectormatch(v0, v1) {
        if (v0.x == v1.x && v0.y == v1.y) return true
        return false
      }
      function vectormatch(v, x, y) {
        if (v.x == x && v.y == y) return true
        return false
      }
      function entitymatch(e, x, y) {
        if (e.x == x && e.y == y) return true
        return false
      }
      function lineflip(l) {
        var temp = l.start
        l.start = l.end
        l.end = temp
      }
      function linesame(l0, l1) {
        if (l0.start == l1.start && l0.end == l1.end) return true
        if (l0.start == l1.end && l0.end == l1.start) return true
        return false
      }
      function linematch(l, s, e) {
        if (l.start == s && l.end == e) return true
        if (l.start == e && l.end == s) return true
        return false
      }
      function linecontains(l, v) {
        if (l.start == v || l.end == v) return true
        return false
      }
      function sectordefault(s) {
        if (s.type != 0) return false
        if (s.fheight != 0) return false
        if (s.cheight != 10) return false
        if (s.ftex != 2) return false
        if (s.ctex != 2) return false
        return true
      }
      //!datapack functions

      //static final variables
      var xentitydirection = new Array(0.0, 0.7, 1.0, 0.7, 0.0, -0.7, -1.0, -0.7)
      var yentitydirection = new Array(-1.0, -0.7, 0.0, 0.7, 1.0, 0.7, 0.0, -0.7)
      //!static final variables

      //main variables
      var canvas
      var context

      var elementzoom
      var elementoffset
      var elementgridscale
      var elementzgrid
      var elementcvec
      var elementcline
      var elementcsub
      var elementcsec
      var elementcnav
      var elementcent
      var elementeditinfo

      var xmpoint = 0
      var ympoint = 0

      var loadopen = false
      var saveopen = false
      var resourceopen = false
      var sectoropen = false
      var modlineopen = false
      var modentityopen = false

      var editmode

      var zoom = 1
      var gridscale = 1
      var zgrid = 1

      var xoffset = 0
      var yoffset = 0

      var drawvectors = false
      var drawlines = true
      var drawlinenormals = true
      var drawgrid = true
      var drawlinelabels = false
      var drawsubsectors = false
      var drawsectors = true
      var drawnavs = true
      var drawlabels = true
      var drawentities = true
      //!main variables

      //map data
      var mapvectors = new Array()
      var maplinedefs = new Array()
      var mapsubsectors = new Array()
      var mapsectors = new Array()
      var mapentities = new Array()
      var mapnavs = new Array()
      //!map data

      //edit mode data
      var xfpoint = -1
      var yfpoint = -1
      var xspoint = -1
      var yspoint = -1
      var svector = null
      var veclist = new Array()
      var sublist = new Array()
      var linelist = new Array()
      var portallist = new Array()
      var editsec = null
      var editline = null
      var editentity = null
      //!edit mode data

      function load() {
        elementzoom = document.getElementById('zoom')
        elementoffset = document.getElementById('offset')
        elementgridscale = document.getElementById('gridscale')
        elementzgrid = document.getElementById('zgrid')
        elementcvec = document.getElementById('cvec')
        elementcline = document.getElementById('cline')
        elementcsub = document.getElementById('csub')
        elementcsec = document.getElementById('csec')
        elementcnav = document.getElementById('cnav')
        elementcent = document.getElementById('cent')
        elementeditinfo = document.getElementById('editinfo')

        canvas = document.getElementById('view')
        updatecanvas()
        window.addEventListener('resize', updatecanvas, false)

        document.onselectstart = function () {
          return false
        }

        document.onmousemove = mousemove
        document.onmousedown = mousedown
        document.onmouseup = mouseup
        window.oncontextmenu = function () {
          return false
        }

        tool(4)
      }

      function updatecanvas() {
        canvas.width = window.innerWidth * 0.8
        canvas.height = window.innerHeight * 0.85
        context = canvas.getContext('2d')
        context.translate(0.5, 0.5)
        context.font = 'bold 10px Courier New'

        draw()
      }

      function draw() {
        elementcvec.innerHTML = 'vectors = ' + mapvectors.length
        elementcline.innerHTML = 'lines = ' + maplinedefs.length
        elementcsub.innerHTML = 'sub sectors = ' + mapsubsectors.length
        elementcsec.innerHTML = 'sectors = ' + mapsectors.length
        elementcnav.innerHTML = 'navs = ' + mapnavs.length
        elementcent.innerHTML = 'entities = ' + mapentities.length

        context.fillStyle = 'rgb(0, 0, 0)'
        context.fillRect(0, 0, canvas.width, canvas.height)

        if (drawgrid && zgrid > 1) {
          context.strokeStyle = 'rgb(51, 51, 51)'

          var xlines = canvas.width / zgrid + 1
          var ylines = canvas.height / zgrid + 1

          for (var i = 0; i < xlines; i++) {
            context.beginPath()
            context.moveTo(zgrid * i, 0)
            context.lineTo(zgrid * i, canvas.height)
            context.stroke()
          }
          for (var i = 0; i < xlines; i++) {
            context.beginPath()
            context.moveTo(0, zgrid * i)
            context.lineTo(canvas.width, zgrid * i)
            context.stroke()
          }
        }
        if (drawsubsectors) {
          Math.seed = 6
          for (var i = 0; i < mapsubsectors.length; i++) {
            var c = 16 + Math.floor(Math.seededrandom() * 65)
            context.fillStyle = 'rgb(' + c + ', ' + c + ', ' + c + ')'

            context.beginPath()
            context.moveTo(zoom * (mapsubsectors[i].vecs[0].x - xoffset), zoom * (mapsubsectors[i].vecs[0].y - yoffset))

            for (var v = 1; v < mapsubsectors[i].vecs.length; v++) context.lineTo(zoom * (mapsubsectors[i].vecs[v].x - xoffset), zoom * (mapsubsectors[i].vecs[v].y - yoffset))

            context.lineTo(zoom * (mapsubsectors[i].vecs[0].x - xoffset), zoom * (mapsubsectors[i].vecs[0].y - yoffset))
            context.closePath()
            context.fill()
          }
        }
        if (drawsectors) {
          Math.seed = 6
          for (var i = 0; i < mapsectors.length; i++) {
            var c = 32 + Math.floor(Math.seededrandom() * 65)
            context.fillStyle = 'rgb(' + c + ', 0, 0)'
            context.strokeStyle = 'rgb(' + c + ', ' + c + ', ' + c + ')'
            for (var s = 0; s < mapsectors[i].subs.length; s++) {
              context.beginPath()
              context.moveTo(zoom * (mapsectors[i].subs[s].vecs[0].x - xoffset), zoom * (mapsectors[i].subs[s].vecs[0].y - yoffset))

              for (var v = 1; v < mapsectors[i].subs[s].vecs.length; v++) context.lineTo(zoom * (mapsectors[i].subs[s].vecs[v].x - xoffset), zoom * (mapsectors[i].subs[s].vecs[v].y - yoffset))

              context.lineTo(zoom * (mapsectors[i].subs[s].vecs[0].x - xoffset), zoom * (mapsectors[i].subs[s].vecs[0].y - yoffset))
              context.closePath()
              context.fill()
            }
          }
          if (editmode == modemodsector && editsec != null) {
            context.fillStyle = 'rgb(0, 0, 128)'
            for (var s = 0; s < editsec.subs.length; s++) {
              context.beginPath()
              context.moveTo(zoom * (editsec.subs[s].vecs[0].x - xoffset), zoom * (editsec.subs[s].vecs[0].y - yoffset))

              for (var v = 1; v < editsec.subs[s].vecs.length; v++) context.lineTo(zoom * (editsec.subs[s].vecs[v].x - xoffset), zoom * (editsec.subs[s].vecs[v].y - yoffset))

              context.lineTo(zoom * (editsec.subs[s].vecs[0].x - xoffset), zoom * (editsec.subs[s].vecs[0].y - yoffset))
              context.closePath()
              context.fill()
            }
          }
          if (drawlabels) {
            context.fillStyle = 'rgb(200, 200, 200)'
            for (var i = 0; i < mapsectors.length; i++) {
              var xmin = mapsectors[i].subs[0].vecs[0].x
              var ymin = mapsectors[i].subs[0].vecs[0].y
              var area = 0
              for (var s = 0; s < mapsectors[i].subs.length; s++) {
                var v0 = mapsectors[i].subs[s].vecs[0]
                var v1 = mapsectors[i].subs[s].vecs[1]
                var v2 = mapsectors[i].subs[s].vecs[2]
                var ar = Math.abs(v0.x * (v1.y - v2.y) + v1.x * (v2.y - v0.y) + v2.x * (v0.y - v1.y)) / 2
                if (ar > area) {
                  area = ar
                  xmin = zoom * ((v0.x + v1.x + v2.x) / 3 - xoffset)
                  ymin = zoom * ((v0.y + v1.y + v2.y) / 3 - yoffset)
                }
              }
              context.fillText(mapsectors[i].type, xmin - 20, ymin)
              context.fillText(mapsectors[i].fheight + ', ' + mapsectors[i].cheight, xmin - 20, ymin + 10)
              context.fillText(mapsectors[i].ftex + ', ' + mapsectors[i].ctex, xmin - 20, ymin + 20)
            }
          }
        }
        if (drawvectors) {
          context.strokeStyle = 'rgb(255, 255, 0)'
          for (var i = 0; i < mapvectors.length; i++) context.strokeRect(zoom * (mapvectors[i].x - xoffset) - 3, zoom * (mapvectors[i].y - yoffset) - 3, 6, 6)

          if (editmode == modemodvector && svector != null) {
            context.strokeStyle = 'rgb(255, 0, 255)'
            context.strokeRect(zoom * (svector.x - xoffset) - 3, zoom * (svector.y - yoffset) - 3, 6, 6)
          }
        }
        if (drawlines) {
          context.strokeStyle = 'rgb(255, 0, 0)'
          if (xfpoint != -1) {
            context.beginPath()
            context.moveTo(zoom * (xfpoint - xoffset), zoom * (yfpoint - yoffset))
            context.lineTo(zoom * (xmidgrid(xmpoint) - xoffset), zoom * (ymidgrid(ympoint) - yoffset))
            context.stroke()

            if (drawlinenormals) {
              var xmid = (zoom * (xfpoint - xoffset) + zoom * (xmidgrid(xmpoint) - xoffset)) / 2
              var ymid = (zoom * (yfpoint - yoffset) + zoom * (ymidgrid(ympoint) - yoffset)) / 2

              var nx = ymidgrid(ympoint) - yfpoint
              var ny = -(xmidgrid(xmpoint) - xfpoint)
              var nm = Math.sqrt(nx * nx + ny * ny)

              nx /= nm
              ny /= nm

              context.beginPath()
              context.moveTo(xmid, ymid)
              context.lineTo(xmid + nx * 8, ymid + ny * 8)
              context.stroke()
            }
          } else if (xspoint != -1) {
            context.strokeStyle = 'rgb(255, 255, 0)'
            context.beginPath()
            context.moveTo(zoom * (xspoint - xoffset), zoom * (yspoint - yoffset))
            context.lineTo(zoom * (xmidgrid(xmpoint) - xoffset), zoom * (ymidgrid(ympoint) - yoffset))
            context.stroke()
            context.strokeStyle = 'rgb(255, 0, 0)'
          }
          for (var i = 0; i < maplinedefs.length; i++) {
            if (maplinedefs[i].mtex == 0) context.strokeStyle = 'rgb(0, 255, 0)'
            else context.strokeStyle = 'rgb(255, 0, 0)'
            context.beginPath()
            context.moveTo(zoom * (maplinedefs[i].start.x - xoffset), zoom * (maplinedefs[i].start.y - yoffset))
            context.lineTo(zoom * (maplinedefs[i].end.x - xoffset), zoom * (maplinedefs[i].end.y - yoffset))
            context.stroke()
          }

          context.strokeStyle = 'rgb(255, 0, 0)'
          if (drawlinenormals) {
            for (var i = 0; i < maplinedefs.length; i++) {
              var xmid = (zoom * (maplinedefs[i].start.x - xoffset) + zoom * (maplinedefs[i].end.x - xoffset)) / 2
              var ymid = (zoom * (maplinedefs[i].start.y - yoffset) + zoom * (maplinedefs[i].end.y - yoffset)) / 2

              var nx = maplinedefs[i].end.y - maplinedefs[i].start.y
              var ny = -(maplinedefs[i].end.x - maplinedefs[i].start.x)
              var nm = Math.sqrt(nx * nx + ny * ny)

              nx /= nm
              ny /= nm

              context.beginPath()
              context.moveTo(xmid, ymid)
              context.lineTo(xmid + nx * 8, ymid + ny * 8)
              context.stroke()
            }
          }
          if (drawlinelabels) {
            context.fillStyle = 'rgb(200, 200, 200)'
            for (var i = 0; i < maplinedefs.length; i++) {
              var xmid = (zoom * (maplinedefs[i].start.x - xoffset) + zoom * (maplinedefs[i].end.x - xoffset)) / 2
              var ymid = (zoom * (maplinedefs[i].start.y - yoffset) + zoom * (maplinedefs[i].end.y - yoffset)) / 2
              context.fillText(maplinedefs[i].ltex + ', ' + maplinedefs[i].mtex + ', ' + maplinedefs[i].utex, xmid + 3, ymid - 5)
            }
          }
          if (editmode == modeaddline) {
            context.strokeStyle = 'rgb(255, 255, 0)'
            context.strokeRect(zoom * (xmidgrid(xmpoint) - xoffset) - 3, zoom * (ymidgrid(ympoint) - yoffset) - 3, 6, 6)
            if (xfpoint != -1) context.strokeRect(zoom * (xfpoint - xoffset) - 3, zoom * (yfpoint - yoffset) - 3, 6, 6)
          }
          if (editmode == modemodline) {
            context.strokeStyle = 'rgb(0, 255, 0)'
            for (var i = 0; i < maplinedefs.length; i++) {
              var xmid = (zoom * (maplinedefs[i].start.x - xoffset) + zoom * (maplinedefs[i].end.x - xoffset)) / 2
              var ymid = (zoom * (maplinedefs[i].start.y - yoffset) + zoom * (maplinedefs[i].end.y - yoffset)) / 2
              context.strokeRect(xmid - 6, ymid - 6, 12, 12)
            }

            if (editline != null) {
              context.strokeStyle = 'rgb(0, 0, 255)'
              var xmid = (zoom * (editline.start.x - xoffset) + zoom * (editline.end.x - xoffset)) / 2
              var ymid = (zoom * (editline.start.y - yoffset) + zoom * (editline.end.y - yoffset)) / 2
              context.strokeRect(xmid - 6, ymid - 6, 12, 12)
            }
          }
        }
        if (drawentities) {
          context.strokeStyle = 'rgb(191, 203, 128)'
          for (var i = 0; i < mapentities.length; i++) {
            context.beginPath()
            context.arc(zoom * (mapentities[i].x - xoffset), zoom * (mapentities[i].y - yoffset), zoom / 2, 0, 2 * Math.PI)
            context.stroke()
            context.beginPath()
            context.moveTo(zoom * (mapentities[i].x - xoffset), zoom * (mapentities[i].y - yoffset))
            context.lineTo(zoom * (mapentities[i].x - xoffset) + xentitydirection[mapentities[i].angle] * (zoom / 2), zoom * (mapentities[i].y - yoffset) + yentitydirection[mapentities[i].angle] * (zoom / 2))
            context.stroke()
          }
          if (editentity != null) {
            context.strokeStyle = 'rgb(255, 203, 255)'
            context.beginPath()
            context.arc(zoom * (editentity.x - xoffset), zoom * (editentity.y - yoffset), zoom / 2, 0, 2 * Math.PI)
            context.stroke()
            context.beginPath()
            context.moveTo(zoom * (editentity.x - xoffset), zoom * (editentity.y - yoffset))
            context.lineTo(zoom * (editentity.x - xoffset) + xentitydirection[editentity.angle] * (zoom / 2), zoom * (editentity.y - yoffset) + yentitydirection[editentity.angle] * (zoom / 2))
            context.stroke()
          } else if (editmode == modeaddentity) {
            context.strokeStyle = 'rgb(191, 255, 128)'
            context.beginPath()
            context.arc(zoom * (xmidgrid(xmpoint) - xoffset), zoom * (ymidgrid(ympoint) - yoffset), zoom / 2, 0, 2 * Math.PI)
            context.stroke()
          }
          if (drawlabels) {
            context.fillStyle = 'rgb(191, 203, 128)'
            for (var i = 0; i < mapentities.length; i++) context.fillText(mapentities[i].reference, zoom * (mapentities[i].x - xoffset) + zoom / 2, zoom * (mapentities[i].y - yoffset) - zoom / 2)
            if (editentity != null) {
              context.fillStyle = 'rgb(255, 203, 255)'
              context.fillText(editentity.reference, zoom * (editentity.x - xoffset) + zoom / 2, zoom * (editentity.y - yoffset) - zoom / 2)
            }
          }
        }
        if (drawnavs) {
          context.strokeStyle = 'rgb(255, 255, 255)'
          for (var i = 0; i < mapnavs.length; i++) {
            context.strokeRect(zoom * (mapnavs[i].x - xoffset) - 3, zoom * (mapnavs[i].y - yoffset) - 3, 6, 6)
            for (var z = 0; z < mapnavs[i].links.length; z++) {
              context.beginPath()
              context.moveTo(zoom * (mapnavs[i].x - xoffset), zoom * (mapnavs[i].y - yoffset))
              context.lineTo(zoom * (mapnavs[i].links[z].x - xoffset), zoom * (mapnavs[i].links[z].y - yoffset))
              context.stroke()
            }
          }
        }
      }

      //mouse functions
      function mousemove(m) {
        xmpoint = m.clientX
        ympoint = m.clientY

        draw()
      }
      function mousedown(m) {
        if (xmpoint > canvas.width) return
        if (ympoint > canvas.height) return
        if (loadopen || saveopen || resourceopen || sectoropen) return

        editmode(m.button == 0 ? true : false)
        draw()
      }
      function mouseup(m) {}
      function xmidgrid(x) {
        return Math.floor((x + zgrid / 2) / zgrid) * gridscale + xoffset
      }
      function ymidgrid(y) {
        return Math.floor((y + zgrid / 2) / zgrid) * gridscale + yoffset
      }
      function xmidscreengrid(x) {
        return Math.floor(((x + zgrid / 2) / zgrid) * gridscale)
      }
      function ymidscreengrid(y) {
        return Math.floor(((y + zgrid / 2) / zgrid) * gridscale)
      }
      //!mouse functions

      //edit mode functions
      function modeoffset(left) {
        var x = xmidscreengrid(xmpoint)
        var y = ymidscreengrid(ympoint)

        xoffset += x - xmidscreengrid(canvas.width / 2)
        yoffset += y - ymidscreengrid(canvas.height / 2)

        if (xoffset < 0) xoffset = 0
        if (yoffset < 0) yoffset = 0

        elementoffset.innerHTML = 'offset = ' + xoffset + ', ' + yoffset
      }
      function modegridscale(left) {
        if (left) {
          if (gridscale < 64) {
            gridscale *= 2
            zgrid = zoom * gridscale
          }
        } else if (gridscale > 1) {
          gridscale /= 2
          zgrid = zoom * gridscale
        }

        elementgridscale.innerHTML = 'grid scale = ' + gridscale
        elementzgrid.innerHTML = 'zgrid = ' + zgrid
      }
      function modemagnify(left) {
        if (left) {
          if (zoom < 64) {
            var x = xmidgrid(xmpoint)
            var y = ymidgrid(ympoint)

            zoom *= 2
            zgrid = zoom * gridscale

            xoffset += x - xmidgrid(canvas.width / 2)
            yoffset += y - ymidgrid(canvas.height / 2)

            if (xoffset < 0) xoffset = 0
            if (yoffset < 0) yoffset = 0
          }
        } else if (zoom > 1) {
          var x = xmidgrid(xmpoint)
          var y = ymidgrid(ympoint)

          zoom /= 2
          zgrid = zoom * gridscale

          xoffset += x - xmidgrid(canvas.width / 2)
          yoffset += y - ymidgrid(canvas.height / 2)

          if (xoffset < 0) xoffset = 0
          if (yoffset < 0) yoffset = 0
        }
        elementzoom.innerHTML = 'zoom = ' + zoom
        elementoffset.innerHTML = 'offset = ' + xoffset + ', ' + yoffset
        elementzgrid.innerHTML = 'zgrid = ' + zgrid
      }
      function modemodsector(left) {
        for (var i = 0; i < mapsubsectors.length; i++) {
          var sub = mapsubsectors[i]
          var points = sub.vecs
          var contains = false
          for (var r = 0, j = points.length - 1; r < points.length; j = r++) {
            if (
              zoom * (points[r].y - yoffset) > ympoint != zoom * (points[j].y - yoffset) > ympoint &&
              xmpoint < ((zoom * (points[j].x - xoffset) - zoom * (points[r].x - xoffset)) * (ympoint - zoom * (points[r].y - yoffset))) / (zoom * (points[j].y - yoffset) - zoom * (points[r].y - yoffset)) + zoom * (points[r].x - xoffset)
            )
              contains = !contains
          }
          if (contains) {
            var found = null
            for (var q = 0; q < mapsectors.length; q++) {
              for (var z = 0; z < mapsectors[q].subs.length; z++)
                if (mapsubsectors[i] == mapsectors[q].subs[z]) {
                  found = mapsectors[q]
                  break
                }
              if (found != null) break
            }
            if (found == null || editsec == found) {
              editsec = null
              if (sectoropen) {
                removehtml('ms0')
                removehtml('ms1')
                removehtml('ms2')
                removehtml('ms3')
                removehtml('ms4')
                removehtml('ms5')
                removehtml('ms6')
                removehtml('ms7')
                removehtml('ms8')
                removehtml('ms9')
                removehtml('ms10')
                sectoropen = false
                elementeditinfo.innerHTML = ''
              }
            } else {
              editsec = found
              if (!sectoropen) {
                sectoropen = true
                elementeditinfo.innerHTML = 'type: ' + editsec.type + '<br>height: ' + editsec.fheight + ', ' + editsec.cheight + '<br>texture: ' + editsec.ftex + ', ' + editsec.ctex
                sethtml(
                  'loadsave',
                  '<button id="ms0" type="button" onclick="ms(0)">+floor</button><button id="ms1" type="button" onclick="ms(1)">+ceil</button><button id="ms2" type="button" onclick="ms(2)">+ftex</button><button id="ms3" type="button" onclick="ms(3)">+ctex</button><button id="ms4" type="button" onclick="ms(4)">+type</button><br><button id="ms5" type="button" onclick="ms(5)">-floor</button><button id="ms6" type="button" onclick="ms(6)">-ceil</button><button id="ms7" type="button" onclick="ms(7)">-ftex</button><button id="ms8" type="button" onclick="ms(8)">-ctex</button><button id="ms9" type="button" onclick="ms(9)">-type</button><br><button id="ms10" type="button" onclick="ms(10)">update</button>'
                )
              }
            }
            break
          }
        }
      }
      function ms(id) {
        switch (id) {
          case 0:
            editsec.fheight++
            break
          case 1:
            editsec.cheight++
            break
          case 2:
            editsec.ftex++
            break
          case 3:
            editsec.ctex++
            break
          case 4:
            editsec.type++
            break
          case 5:
            if (editsec.fheight > 0) editsec.fheight--
            break
          case 6:
            if (editsec.cheight > 0) editsec.cheight--
            break
          case 7:
            if (editsec.ftex > 0) editsec.ftex--
            break
          case 8:
            if (editsec.ctex > 0) editsec.ctex--
            break
          case 9:
            if (editsec.type > 0) editsec.type--
            break
          case 10:
            removehtml('ms0')
            removehtml('ms1')
            removehtml('ms2')
            removehtml('ms3')
            removehtml('ms4')
            removehtml('ms5')
            removehtml('ms6')
            removehtml('ms7')
            removehtml('ms8')
            removehtml('ms9')
            removehtml('ms10')
            editsec = null
            sectoropen = false
            break
        }
        if (editsec == null) {
          elementeditinfo.innerHTML = ''
          autoupdate()
        } else elementeditinfo.innerHTML = 'type: ' + editsec.type + '<br>height: ' + editsec.fheight + ', ' + editsec.cheight + '<br>texture: ' + editsec.ftex + ', ' + editsec.ctex

        draw()
      }
      function modemodvector(left) {
        if (left) {
          if (svector == null) {
            for (var i = 0; i < mapvectors.length; i++) {
              var xmid = zoom * (mapvectors[i].x - xoffset)
              var ymid = zoom * (mapvectors[i].y - yoffset)
              if (Math.sqrt((xmid - xmpoint) * (xmid - xmpoint) + (ymid - ympoint) * (ymid - ympoint)) < 8) {
                svector = mapvectors[i]
                break
              }
            }
          } else {
            var x = xmidgrid(xmpoint)
            var y = ymidgrid(ympoint)
            var vec

            for (var i = 0; i < mapvectors.length; i++)
              if (mapvectors[i] != svector && vectormatch(mapvectors[i], x, y)) {
                vec = mapvectors[i]
                break
              }

            if (vec == null) {
              svector.x = x
              svector.y = y
            } else {
              for (var i = 0; i < maplinedefs.length; i++) {
                if (linecontains(maplinedefs[i], svector)) {
                  if (maplinedefs[i].start == svector) maplinedefs[i].start = vec
                  else maplinedefs[i].end = vec

                  if (maplinedefs[i].start == maplinedefs[i].end) {
                    maplinedefs.splice(i, 1)
                    i--
                  }
                }
              }

              var vecfound = false
              for (var i = 0; i < maplinedefs.length; i++)
                if (linecontains(maplinedefs[i], vec)) {
                  vecfound = true
                  break
                }

              if (!vecfound) mapvectors.splice(mapvectors.indexOf(vec), 1)

              for (var i = 0; i < maplinedefs.length; i++)
                for (var ii = i + 1; ii < maplinedefs.length; ii++)
                  if (linesame(maplinedefs[i], maplinedefs[ii])) {
                    maplinedefs.splice(ii, 1)
                    ii--
                  }

              mapvectors.splice(mapvectors.indexOf(svector), 1)
            }
            svector = null
            autoupdate()
          }
        } else {
          svector = null
        }
      }
      function modemodline(left) {
        if (left) {
          for (var i = 0; i < maplinedefs.length; i++) {
            var xmid = (zoom * (maplinedefs[i].start.x - xoffset) + zoom * (maplinedefs[i].end.x - xoffset)) / 2
            var ymid = (zoom * (maplinedefs[i].start.y - yoffset) + zoom * (maplinedefs[i].end.y - yoffset)) / 2
            if (Math.sqrt((xmid - xmpoint) * (xmid - xmpoint) + (ymid - ympoint) * (ymid - ympoint)) < 8) {
              lineflip(maplinedefs[i])
              autoupdate()
              break
            }
          }
        } else {
          var previous = editline
          editline = null
          for (var i = 0; i < maplinedefs.length; i++) {
            var xmid = (zoom * (maplinedefs[i].start.x - xoffset) + zoom * (maplinedefs[i].end.x - xoffset)) / 2
            var ymid = (zoom * (maplinedefs[i].start.y - yoffset) + zoom * (maplinedefs[i].end.y - yoffset)) / 2
            if (Math.sqrt((xmid - xmpoint) * (xmid - xmpoint) + (ymid - ympoint) * (ymid - ympoint)) < 8) {
              if (previous == maplinedefs[i]) {
                editline = null
                break
              }
              editline = maplinedefs[i]
              if (!modlineopen) {
                elementeditinfo.innerHTML = 'lower: ' + editline.ltex + '<br>middle: ' + editline.mtex + '<br>upper: ' + editline.utex
                modlineopen = true
                sethtml(
                  'loadsave',
                  '<button id="ml0" type="button" onclick="ml(0)">+ltex</button><button id="ml1" type="button" onclick="ml(1)">+mtex</button><button id="ml2" type="button" onclick="ml(2)">+utex</button><br><button id="ml3" type="button" onclick="ml(3)">-ltex</button><button id="ml4" type="button" onclick="ml(4)">-mtex</button><button id="ml5" type="button" onclick="ml(5)">-utex</button><br><button id="ml6" type="button" onclick="ml(6)">update</button>'
                )
              }
              break
            }
          }
          if (editline == null && modlineopen) {
            elementeditinfo.innerHTML = ''
            removehtml('ml0')
            removehtml('ml1')
            removehtml('ml2')
            removehtml('ml3')
            removehtml('ml4')
            removehtml('ml5')
            removehtml('ml6')
            modlineopen = false
          }
        }
      }
      function ml(id) {
        switch (id) {
          case 0:
            editline.ltex++
            break
          case 1:
            editline.mtex++
            break
          case 2:
            editline.utex++
            break
          case 3:
            if (editline.ltex > 0) editline.ltex--
            break
          case 4:
            if (editline.mtex > 0) editline.mtex--
            break
          case 5:
            if (editline.utex > 0) editline.utex--
            break
          case 6:
            removehtml('ml0')
            removehtml('ml1')
            removehtml('ml2')
            removehtml('ml3')
            removehtml('ml4')
            removehtml('ml5')
            removehtml('ml6')
            editline = null
            modlineopen = false
            break
        }
        if (editline == null) elementeditinfo.innerHTML = ''
        else elementeditinfo.innerHTML = 'lower: ' + editline.ltex + '<br>middle: ' + editline.mtex + '<br>upper: ' + editline.utex
        autoupdate()
        draw()
      }
      function modeaddline(left) {
        if (!left) {
          if (xfpoint != -1) {
            xfpoint = -1
            yfpoint = -1
          } else if (xspoint == -1) {
            xspoint = xmidgrid(xmpoint)
            yspoint = ymidgrid(ympoint)
          } else {
            var x = xmidgrid(xmpoint)
            var y = ymidgrid(ympoint)

            var xs = xspoint
            xspoint = -1
            var ys = yspoint
            yspoint = -1

            var linedeflength = maplinedefs.length
            for (var l = 0; l < linedeflength; l++) {
              var ip = lineintersectionpoint(x, y, xs, ys, maplinedefs[l].start.x, maplinedefs[l].start.y, maplinedefs[l].end.x, maplinedefs[l].end.y)
              if (ip != null) {
                var oldline = maplinedefs[l]

                maplinedefs.splice(l, 1)
                linedeflength--
                l--

                var found = false
                for (var i = 0; i < maplinedefs.length; i++)
                  if (linecontains(maplinedefs[i], oldline.start)) {
                    found = true
                    break
                  }
                if (!found) mapvectors.splice(mapvectors.indexOf(oldline.start), 1)

                found = false
                for (var i = 0; i < maplinedefs.length; i++)
                  if (linecontains(maplinedefs[i], oldline.end)) {
                    found = true
                    break
                  }
                if (!found) mapvectors.splice(mapvectors.indexOf(oldline.end), 1)
              }
            }
            autoupdate()
          }
          return
        }

        if (xspoint != -1) {
          xspoint = -1
          yspoint = -1
        } else if (xfpoint == -1) {
          xfpoint = xmidgrid(xmpoint)
          yfpoint = ymidgrid(ympoint)
        } else {
          var x = xmidgrid(xmpoint)
          var y = ymidgrid(ympoint)

          var xf = xfpoint
          xfpoint = -1
          var yf = yfpoint
          yfpoint = -1

          if (xf == x && yf == y) return

          var s, e
          for (var i = 0; i < mapvectors.length; i++) {
            if (vectormatch(mapvectors[i], xf, yf)) {
              s = mapvectors[i]
              break
            }
          }
          for (var i = 0; i < mapvectors.length; i++) {
            if (vectormatch(mapvectors[i], x, y)) {
              e = mapvectors[i]
              break
            }
          }

          var newlinedef = true
          if (s != null && e != null)
            for (var i = 0; i < maplinedefs.length; i++)
              if (linematch(maplinedefs[i], s, e)) {
                newlinedef = false
                break
              }

          if (newlinedef) {
            var snew = false
            if (s == null) {
              s = new vector(xf, yf)
              snew = true
            }
            var enew = false
            if (e == null) {
              e = new vector(x, y)
              enew = true
            }

            var safe = true
            for (var l = 0; l < maplinedefs.length; l++) {
              if (linecontains(maplinedefs[l], s) || linecontains(maplinedefs[l], e)) continue
              if (lineintersection(s.x, s.y, e.x, e.y, maplinedefs[l].start.x, maplinedefs[l].start.y, maplinedefs[l].end.x, maplinedefs[l].end.y)) {
                safe = false
                break
              }
            }

            if (safe) {
              if (snew) mapvectors.push(s)
              if (enew) mapvectors.push(e)

              maplinedefs.push(new linedef(s, e))
              autoupdate()
            }
          }
        }
      }
      function modeaddentity(left) {
        var x = xmidgrid(xmpoint)
        var y = ymidgrid(ympoint)

        var found = null
        for (var i = 0; i < mapentities.length; i++)
          if (mapentities[i].x == x && mapentities[i].y == y) {
            found = mapentities[i]
            break
          }

        if (left) {
          if (modentityopen) {
            if (found != null) editentity = found
          } else {
            if (editentity != null) {
              if (found != null && editentity != found) return
              editentity.x = x
              editentity.y = y
              editentity = null
            } else if (found == null) mapentities.push(new entity(x, y))
            else editentity = found
          }
        } else if (found != null) {
          editentity = found
          elementeditinfo.innerHTML = 'angle: ' + editentity.angle + '<br>reference: ' + editentity.reference
          if (!modentityopen) {
            modentityopen = true
            sethtml(
              'loadsave',
              '<button id="me0" type="button" onclick="me(0)">+angle</button><button id="me1" type="button" onclick="me(1)">+type</button><button id="me5" type="button" onclick="me(5)">delete</button><br><button id="me2" type="button" onclick="me(2)">-angle</button><button id="me3" type="button" onclick="me(3)">-type</button><br><button id="me4" type="button" onclick="me(4)">update</button>'
            )
          }
        }
      }
      function me(id) {
        switch (id) {
          case 0:
            editentity.angle++
            if (editentity.angle == 8) editentity.angle = 0
            break
          case 1:
            editentity.reference++
            break
          case 2:
            editentity.angle--
            if (editentity.angle == -1) editentity.angle = 7
            break
          case 3:
            if (editentity.reference > 0) editentity.reference--
            break
          case 5:
            for (var i = 0; i < mapentities.length; i++)
              if (mapentities[i] == editentity) {
                mapentities.splice(i, 1)
                break
              }
          case 4:
            removehtml('me0')
            removehtml('me1')
            removehtml('me2')
            removehtml('me3')
            removehtml('me4')
            removehtml('me5')
            editentity = null
            modentityopen = false
            break
        }
        if (editentity == null) elementeditinfo.innerHTML = ''
        else elementeditinfo.innerHTML = 'angle: ' + editentity.angle + '<br>reference: ' + editentity.reference

        draw()
      }
      //!edit mode functions

      //updates
      function autoupdate() {
        //updaterecurse();
        updateclockwise()
        updateareas()
        updatelines()
        updatenavs()
      }
      function updaterecurse() {}
      function updateclockwise() {
        for (var z = 0; z < maplinedefs.length; z++) {
          var line = maplinedefs[z]
          var left = null
          var right = null
          var starting = null
          var ending = null
          for (var i = 0; i < maplinedefs.length; i++) {
            if (i == z) continue
            else if (line.start == maplinedefs[i].start) {
              starting = maplinedefs[i]
              break
            }
          }
          for (var i = 0; i < maplinedefs.length; i++) {
            if (i == z) continue
            else if (line.start == maplinedefs[i].end) {
              left = maplinedefs[i]
              break
            }
          }
          for (var i = 0; i < maplinedefs.length; i++) {
            if (i == z) continue
            else if (line.end == maplinedefs[i].end) {
              ending = maplinedefs[i]
              break
            }
          }
          for (var i = 0; i < maplinedefs.length; i++) {
            if (i == z) continue
            else if (line.end == maplinedefs[i].start) {
              right = maplinedefs[i]
              break
            }
          }

          if ((left == null && starting == null) || (right == null && ending == null)) continue

          if (left != null && right != null) continue
          if (left == null && right != null) continue

          var temp = line.start
          line.start = line.end
          line.end = temp
        }
      }
      function areafindstart() {
        for (var z = 0; z < maplinedefs.length; z++) {
          var needed = true
          for (var s = 0; s < mapsectors.length; s++) {
            for (var v = 0; v < mapsectors[s].lines.length; v++)
              if (maplinedefs[z] == mapsectors[s].lines[v]) {
                needed = false
                break
              }
            if (!needed) break
          }
          if (needed) return maplinedefs[z]
        }
      }
      function areaclockwise(poly) {
        var sum = 0
        for (var p = 0; p < poly.length; p++) {
          var p1 = p + 1 == poly.length ? 0 : p + 1
          sum += (poly[p1].x - poly[p].x) * (poly[p1].y + poly[p].y)
        }
        if (sum < 0) {
          var polytemp = poly[0]
          poly[0] = poly[1]
          poly[1] = polytemp
          var p = 2
          while (true) {
            if (p >= poly.length - p + 1) break
            polytemp = poly[p]
            poly[p] = poly[poly.length - p + 1]
            poly[poly.length - p + 1] = polytemp
            p++
          }
        }
      }
      function areatriangulate(poly, subs) {
        var p = 0
        while (true) {
          if (poly.length == 3) break

          if (p == poly.length) p = 0
          var p1 = p + 1 == poly.length ? 0 : p + 1
          var p2 = p1 + 1 == poly.length ? 0 : p1 + 1

          var points = new Array(poly[p], poly[p1], poly[p2])
          var open = true
          for (var i = 0; i < poly.length; i++) {
            if (i == p || i == p1 || i == p2) continue
            var inside = false
            for (var r = 0, j = points.length - 1; r < points.length; j = r++)
              if (points[r].y > poly[i].y != points[j].y > poly[i].y && poly[i].x < ((points[j].x - points[r].x) * (poly[i].y - points[r].y)) / (points[j].y - points[r].y) + points[r].x) inside = !inside
            if (inside) {
              p++
              open = false
              break
            }
          }
          if (!open) continue

          var angle = ((Math.atan2(poly[p].y - poly[p1].y, poly[p].x - poly[p1].x) - Math.atan2(poly[p1].y - poly[p2].y, poly[p1].x - poly[p2].x)) * 180) / Math.PI
          if (angle >= 360) angle %= 360
          else while (angle < 0) angle += 360
          if (angle > 180) {
            p++
            continue
          }

          subs.push(new subsector(new Array(poly[p], poly[p1], poly[p2])))
          mapsubsectors.push(subs[subs.length - 1])

          poly.splice(p1, 1)
        }
        subs.push(new subsector(poly.slice(0)))
        mapsubsectors.push(subs[subs.length - 1])
      }
      function areapoly(start, poly, polylines, gates) {
        var first = start
        var clockwise = true
        while (true) {
          var second = null
          var secondangle = 1000
          var clockchange = false
          for (var z = 0; z < maplinedefs.length; z++) {
            if (first == maplinedefs[z]) continue
            var angle = ((Math.atan2(maplinedefs[z].start.y - maplinedefs[z].end.y, maplinedefs[z].start.x - maplinedefs[z].end.x) - Math.atan2(first.start.y - first.end.y, first.start.x - first.end.x)) * 180) / Math.PI

            if (clockwise) {
              if (first.end == maplinedefs[z].start) {
                angle += 180
                if (angle >= 360) angle %= 360
                else while (angle < 0) angle += 360
                if (angle < secondangle) {
                  second = maplinedefs[z]
                  secondangle = angle
                  clockchange = false
                }
              } else if (first.end == maplinedefs[z].end) {
                if (angle >= 360) angle %= 360
                else while (angle < 0) angle += 360
                if (angle < secondangle) {
                  second = maplinedefs[z]
                  secondangle = angle
                  clockchange = true
                }
              }
            } else {
              if (first.start == maplinedefs[z].end) {
                angle += 180
                if (angle >= 360) angle %= 360
                else while (angle < 0) angle += 360
                if (angle < secondangle) {
                  second = maplinedefs[z]
                  secondangle = angle
                  clockchange = false
                }
              } else if (first.start == maplinedefs[z].start) {
                if (angle >= 360) angle %= 360
                else while (angle < 0) angle += 360
                if (angle < secondangle) {
                  second = maplinedefs[z]
                  secondangle = angle
                  clockchange = true
                }
              }
            }
          }
          if (second == null || start == second) break
          if (clockchange) clockwise = !clockwise
          if (secondangle != 0 && secondangle != 180) {
            if (clockwise) poly.push(second.start)
            else poly.push(second.end)
          }

          var isportal = false
          for (var s = 0; s < mapsectors.length; s++) {
            for (var v = 0; v < mapsectors[s].lines.length; v++)
              if (second == mapsectors[s].lines[v]) {
                gates.push(second)
                isportal = true
                break
              }
            if (isportal) break
          }
          if (!isportal) polylines.push(second)

          first = second
        }
      }
      function updateareas() {
        var oldsectors = mapsectors.slice(0)

        mapsectors.splice(0, mapsectors.length)
        mapsubsectors.splice(0, mapsubsectors.length)

        while (true) {
          var start = areafindstart()
          if (start == null) break

          var poly = new Array(start.start)
          var polylines = new Array(start)
          var gates = new Array()
          var subs = new Array()

          areapoly(start, poly, polylines, gates)
          if (poly.length < 3) break
          areaclockwise(poly)
          areatriangulate(poly, subs)

          mapsectors.push(new sector(subs.slice(0), polylines.slice(0), gates.slice(0)))
        }

        for (var i = 0; i < oldsectors.length; i++) {
          var equals = 0
          var linesfound = 0
          var match = null
          for (var z = 0; z < mapsectors.length; z++) {
            if (!sectordefault(mapsectors[z])) continue

            var testequal = 0
            for (var k = 0; k < oldsectors[i].poly.length; k++) {
              for (var l = 0; l < mapsectors[z].poly.length; l++) {
                if (oldsectors[i].poly[k] == mapsectors[z].poly[l]) {
                  testequal++
                  break
                }
              }
            }
            if (testequal > equals) {
              match = mapsectors[z]
              equals = testequal
            } else if (testequal == equals) {
              var testlines = 0
              for (var k = 0; k < oldsectors[i].lines.length; k++) {
                for (var l = 0; l < mapsectors[z].lines.length; l++) {
                  if (oldsectors[i].lines[k] == mapsectors[z].lines[l]) {
                    testlines++
                    break
                  }
                }
              }
              if (testlines > linesfound) {
                match = mapsectors[z]
                linesfound = testlines
              }
            }
          }
          if (match != null) {
            match.type = oldsectors[i].type
            match.fheight = oldsectors[i].fheight
            match.cheight = oldsectors[i].cheight
            match.ftex = oldsectors[i].ftex
            match.ctex = oldsectors[i].ctex
          }
        }
      }
      function updatelines() {
        for (var l = 0; l < mapsectors.length; l++) {
          for (var k = 0; k < mapsectors[l].lines.length; k++) if (mapsectors[l].lines[k].mtex == 0) mapsectors[l].lines[k].mtex = 1
        }
        for (var i = 0; i < mapsectors.length; i++) {
          for (var z = 0; z < mapsectors[i].portals.length; z++) {
            for (var l = 0; l < mapsectors.length; l++) {
              if (l == i) continue
              for (var k = 0; k < mapsectors[l].lines.length; k++) {
                if (mapsectors[i].portals[z] == mapsectors[l].lines[k]) {
                  mapsectors[l].lines[k].mtex = 0

                  var xmid = (mapsectors[l].lines[k].start.x + mapsectors[l].lines[k].end.x) / 2
                  var ymid = (mapsectors[l].lines[k].start.y + mapsectors[l].lines[k].end.y) / 2

                  var nx = mapsectors[l].lines[k].end.y - mapsectors[l].lines[k].start.y
                  var ny = -(mapsectors[l].lines[k].end.x - mapsectors[l].lines[k].start.x)
                  var nm = Math.sqrt(nx * nx + ny * ny)

                  nx /= nm
                  ny /= nm

                  var lx = xmid + nx * 0.25
                  var ly = ymid + ny * 0.25

                  var pointingout = false
                  for (var u = 0; u < mapsectors[l].subs.length; u++) {
                    var points = new Array(mapsectors[l].subs[u].vecs[0], mapsectors[l].subs[u].vecs[1], mapsectors[l].subs[u].vecs[2])

                    for (var r = 0, j = points.length - 1; r < points.length; j = r++)
                      if (points[r].y > ly != points[j].y > ly && lx < ((points[j].x - points[r].x) * (ly - points[r].y)) / (points[j].y - points[r].y) + points[r].x) pointingout = !pointingout
                    if (pointingout) break
                  }

                  if ((pointingout && mapsectors[i].fheight < mapsectors[l].fheight) || (!pointingout && mapsectors[i].fheight > mapsectors[l].fheight)) {
                    var temp = mapsectors[l].lines[k].start
                    mapsectors[l].lines[k].start = mapsectors[l].lines[k].end
                    mapsectors[l].lines[k].end = temp
                  }

                  if (mapsectors[i].fheight > mapsectors[l].fheight) {
                    mapsectors[l].lines[k].plus = mapsectors[i]
                    mapsectors[l].lines[k].minus = mapsectors[l]
                  } else {
                    mapsectors[l].lines[k].plus = mapsectors[l]
                    mapsectors[l].lines[k].minus = mapsectors[i]
                  }
                }
              }
            }
          }
        }
        for (var i = 0; i < mapsectors.length; i++) {
          for (var z = 0; z < mapsectors.length; z++) {
            if (i == z) continue

            var sharedvec = false
            for (var l = 0; l < mapsectors[i].poly.length; l++) {
              for (var s = 0; s < mapsectors[z].poly.length; s++)
                if (mapsectors[i].poly[l] == mapsectors[z].poly[s]) {
                  sharedvec = true
                  break
                }
              if (sharedvec) break
            }
            if (sharedvec) continue

            var sectorinside = false
            for (var l = 0; l < mapsectors[i].subs.length; l++) {
              var points = new Array(mapsectors[i].subs[l].vecs[0], mapsectors[i].subs[l].vecs[1], mapsectors[i].subs[l].vecs[2])
              for (var k = 0; k < mapsectors[z].poly.length; k++) {
                var lv = mapsectors[z].poly[k]

                for (var r = 0, j = points.length - 1; r < points.length; j = r++)
                  if (points[r].y > lv.y != points[j].y > lv.y && lv.x < ((points[j].x - points[r].x) * (lv.y - points[r].y)) / (points[j].y - points[r].y) + points[r].x) sectorinside = !sectorinside
                if (sectorinside) break
              }
              if (sectorinside) break
            }

            if (sectorinside) {
              for (var k = 0; k < mapsectors[z].lines.length; k++) {
                var xmid = (mapsectors[z].lines[k].start.x + mapsectors[z].lines[k].end.x) / 2
                var ymid = (mapsectors[z].lines[k].start.y + mapsectors[z].lines[k].end.y) / 2

                var nx = mapsectors[z].lines[k].end.y - mapsectors[z].lines[k].start.y
                var ny = -(mapsectors[z].lines[k].end.x - mapsectors[z].lines[k].start.x)
                var nm = Math.sqrt(nx * nx + ny * ny)

                nx /= nm
                ny /= nm

                var lx = xmid + nx * 0.25
                var ly = ymid + ny * 0.25

                var pointingout = false
                for (var u = 0; u < mapsectors[z].subs.length; u++) {
                  var points = new Array(mapsectors[z].subs[u].vecs[0], mapsectors[z].subs[u].vecs[1], mapsectors[z].subs[u].vecs[2])

                  for (var r = 0, j = points.length - 1; r < points.length; j = r++)
                    if (points[r].y > ly != points[j].y > ly && lx < ((points[j].x - points[r].x) * (ly - points[r].y)) / (points[j].y - points[r].y) + points[r].x) pointingout = !pointingout
                  if (pointingout) break
                }

                if (pointingout) {
                  var temp = mapsectors[z].lines[k].start
                  mapsectors[z].lines[k].start = mapsectors[z].lines[k].end
                  mapsectors[z].lines[k].end = temp
                }
              }
            }
          }
        }
      }
      function updatenavs() {
        mapnavs.splice(0, mapnavs.length)
        for (
          var i = 0;
          i < maplinedefs.length;
          i++ //find edges
        ) {
          var first = maplinedefs[i]
          if (first.mtex == 0) continue
          for (var z = 0; z < maplinedefs.length; z++) {
            if (z == i) continue
            if (first.end == maplinedefs[z].start) {
              var second = maplinedefs[z]
              var angle = ((Math.atan2(first.start.y - first.end.y, first.start.x - first.end.x) - Math.atan2(second.start.y - second.end.y, second.start.x - second.end.x)) * 180) / Math.PI
              if (angle >= 360) angle %= 360
              else while (angle < 0) angle += 360
              if (angle > 180) {
                var safe = true
                for (var v = 0; v < mapnavs.length; v++)
                  if (mapnavs[v].first.end == first.end) {
                    safe = false
                    break
                  }
                if (safe) {
                  var newnav = new navpoint(0, first, second, null)
                  mapnavs.push(newnav)

                  for (var f = 0; f < mapsectors.length; f++) {
                    var navinside = false
                    for (var b = 0; b < mapsectors[f].subs.length; b++) {
                      var points = new Array(mapsectors[f].subs[b].vecs[0], mapsectors[f].subs[b].vecs[1], mapsectors[f].subs[b].vecs[2])
                      for (var r = 0, j = points.length - 1; r < points.length; j = r++)
                        if (points[r].y > newnav.y != points[j].y > newnav.y && newnav.x < ((points[j].x - points[r].x) * (newnav.y - points[r].y)) / (points[j].y - points[r].y) + points[r].x) navinside = !navinside
                      if (navinside) break
                    }
                    if (navinside) {
                      newnav.sector = mapsectors[f]
                      break
                    }
                  }
                }
                break
              }
            }
          }
        }
        for (
          var i = 0;
          i < mapsectors.length;
          i++ //find centers
        ) {
          if (mapsectors[i].lines.length + mapsectors[i].portals.length > 4) continue
          var allportals = mapsectors[i].portals.length
          for (var s = 0; s < mapsectors[i].lines.length; s++) if (mapsectors[i].lines[s].plus != null) allportals++
          if (allportals < 2) continue

          var xmids = new Array()
          var ymids = new Array()
          for (var s = 0; s < mapsectors[i].subs.length; s++) {
            var v0 = mapsectors[i].subs[s].vecs[0]
            var v1 = mapsectors[i].subs[s].vecs[1]
            var v2 = mapsectors[i].subs[s].vecs[2]

            xmids.push((v0.x + v1.x + v2.x) / 3)
            ymids.push((v0.y + v1.y + v2.y) / 3)
          }
          var xcenter = 0
          var ycenter = 0
          for (var s = 0; s < xmids.length; s++) {
            xcenter += xmids[s]
            ycenter += ymids[s]
          }
          xcenter /= xmids.length
          ycenter /= xmids.length

          mapnavs.push(new navpoint(1, Math.round(xcenter), Math.round(ycenter), mapsectors[i]))
        }
        for (
          var i = 0;
          i < mapnavs.length;
          i++ //link
        ) {
          for (var z = i + 1; z < mapnavs.length; z++) {
            var first = mapnavs[i]
            var second = mapnavs[z]

            var linetraversal = new Array()
            var traversalpoint = new Array()

            var firstsafe = true
            var secondsafe = true
            for (var l = 0; l < maplinedefs.length; l++) {
              var ip = lineintersectionpoint(first.x, first.y, second.x, second.y, maplinedefs[l].start.x, maplinedefs[l].start.y, maplinedefs[l].end.x, maplinedefs[l].end.y)
              if (ip == null) continue

              if (maplinedefs[l].mtex == 0) {
                linetraversal.push(maplinedefs[l])
                traversalpoint.push(ip)
              } else {
                firstsafe = false
                secondsafe = false
                break
              }
            }

            if (linetraversal.length > 0 && firstsafe) {
              var begin
              var currentheight

              if (first.sector.fheight > second.sector.fheight) begin = first
              else begin = second
              currentheight = begin.sector.fheight

              for (var t = 0; t < linetraversal.length - 1; t++) {
                var a = traversalpoint[t]
                var b = traversalpoint[t + 1]

                var dist0 = (begin.x - a[0]) * (begin.x - a[0]) + (begin.y - a[1]) * (begin.y - a[1])
                var dist1 = (begin.x - b[0]) * (begin.x - b[0]) + (begin.y - b[1]) * (begin.y - b[1])

                if (dist0 > dist1) {
                  var temp = linetraversal[t]
                  linetraversal[t] = linetraversal[t + 1]
                  linetraversal[t + 1] = temp

                  traversalpoint[t] = b
                  traversalpoint[t + 1] = a

                  t = -1
                }
              }

              for (var t = 0; t < linetraversal.length; t++) {
                if (currentheight == linetraversal[t].plus.fheight) currentheight = linetraversal[t].minus.fheight
                else if (currentheight == linetraversal[t].minus.fheight) {
                  if (linetraversal[t].plus.fheight - currentheight >= 3) {
                    if (begin == first) firstsafe = false
                    else secondsafe = false
                    break
                  }
                  currentheight = linetraversal[t].plus.fheight
                }
              }

              if (first.sector.fheight < second.sector.fheight) begin = first
              else begin = second
              currentheight = begin.sector.fheight

              for (var t = linetraversal.length - 1; t >= 0; t--) {
                if (currentheight == linetraversal[t].plus.fheight) currentheight = linetraversal[t].minus.fheight
                else if (currentheight == linetraversal[t].minus.fheight) {
                  if (linetraversal[t].plus.fheight - currentheight >= 3) {
                    if (begin == first) firstsafe = false
                    else secondsafe = false
                    break
                  }
                  currentheight = linetraversal[t].plus.fheight
                }
              }
            }

            if (firstsafe) first.links.push(second)
            if (secondsafe) second.links.push(first)
          }
        }
        /*for (var i = 0; i < mapnavs.length; i++) //remove excess links
                    {
                        for (var z = 0; z < mapnavs[i].links.length; z++)
                        {
                            var zdist = Math.sqrt((mapnavs[i].links[z].x - mapnavs[i].x) * (mapnavs[i].links[z].x - mapnavs[i].x) + (mapnavs[i].links[z].y - mapnavs[i].y) * (mapnavs[i].links[z].y - mapnavs[i].y));
                            var znav; for (var o = 0; o < mapnavs.length; o++) if (mapnavs[o] == mapnavs[i].links[z]) {znav = o; break}
                            var znavi = -1; for (var o = 0; o < mapnavs[znav].links.length; o++) if (mapnavs[znav].links[o] == mapnavs[i]) {znavi = o; break}
                            
                            for (var w = 0; w < mapnavs[i].links.length; w++)
                            {
                                if (w == z) continue;
                                
                                var wdist = Math.sqrt((mapnavs[i].links[w].x - mapnavs[i].x) * (mapnavs[i].links[w].x - mapnavs[i].x) + (mapnavs[i].links[w].y - mapnavs[i].y) * (mapnavs[i].links[w].y - mapnavs[i].y));
                                var wnav; for (var o = 0; o < mapnavs.length; o++) if (mapnavs[o] == mapnavs[i].links[w]) {wnav = o; break}
                                var wnavi = -1; for (var o = 0; o < mapnavs[wnav].links.length; o++) if (mapnavs[wnav].links[o] == mapnavs[i]) {wnavi = o; break}
                            
                                if (zdist > wdist)
                                {
                                    for (var o = 0; o < mapnavs[wnav].links.length; o++)
                                    {
                                        if (mapnavs[wnav].links[o] == mapnavs[znav])
                                        {
                                            mapnavs[i].links.splice(z, 1);
                                            w = mapnavs[i].links.length;
                                            z--;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }*/
      }
      //!updates

      function resourceoptions() {
        if (loadopen || saveopen || sectoropen || modlineopen || modentityopen) return
        if (resourceopen) {
          removehtml('loadtext')
          removehtml('loadfinish')
          resourceopen = false
          return
        }

        resourceopen = true
        sethtml('loadsave', '<textarea id="loadtext" style="white-space: nowrap; resize: none; width: 100%; height: 85%;"></textarea><br><button id="loadfinish" type="button" onclick="resourcefinish()">finish wtd</button>')
      }
      function loadtext() {
        if (resourceopen || saveopen || sectoropen || modlineopen || modentityopen) return
        if (loadopen) {
          removehtml('loadtext')
          removehtml('loadfinish')
          loadopen = false
          return
        }

        loadopen = true
        sethtml('loadsave', '<textarea id="loadtext" style="white-space: nowrap; resize: none; width: 100%; height: 85%;"></textarea><br><button id="loadfinish" type="button" onclick="loadfinish()">finish loading</button>')
      }
      function resourcefinish() {
        loadwtd()

        removehtml('loadtext')
        removehtml('loadfinish')
        resourceopen = false
      }
      function loadfinish() {
        loadfile()

        removehtml('loadtext')
        removehtml('loadfinish')
        loadopen = false
      }
      function savetext() {
        if (resourceopen || loadopen || sectoropen || modlineopen || modentityopen) return
        if (saveopen) {
          removehtml('savetext')
          saveopen = false
          return
        }

        saveopen = true
        sethtml('loadsave', '<textarea id="savetext" style="white-space: nowrap; resize: none; width: 100%; height: 85%;">' + savefile() + '</textarea>')
        document.getElementById('savetext').select()
      }
      function savefile() {
        if (mapvectors.length < 3) return 'map incomplete - at least 3 vectors needed'

        zoom = 1
        elementzoom.innerHTML = 'zoom = ' + zoom
        gridscale = 1
        elementgridscale.innerHTML = 'grid scale = ' + gridscale
        zgrid = 1
        elementzgrid.innerHTML = 'zgrid = ' + zgrid
        xoffset = 0
        yoffset = 0
        elementoffset.innerHTML = 'offset = ' + xoffset + ', ' + yoffset

        var xmin = mapvectors[0].x
        var ymin = mapvectors[0].y
        for (var i = 1; i < mapvectors.length; i++) {
          if (mapvectors[i].x < xmin) xmin = mapvectors[i].x
          if (mapvectors[i].y < ymin) ymin = mapvectors[i].y
        }
        for (var i = 1; i < mapentities.length; i++) {
          if (mapentities[i].x < xmin) xmin = mapentities[i].x
          if (mapentities[i].y < ymin) ymin = mapentities[i].y
        }
        for (var i = 0; i < mapvectors.length; i++) {
          mapvectors[i].x -= xmin - 1
          mapvectors[i].y -= ymin - 1
        }
        for (var i = 0; i < mapentities.length; i++) {
          mapentities[i].x -= xmin - 1
          mapentities[i].y -= ymin - 1
        }

        var xmax = mapvectors[0].x
        var ymax = mapvectors[0].y
        for (var i = 1; i < mapvectors.length; i++) {
          if (mapvectors[i].x > xmax) xmax = mapvectors[i].x
          if (mapvectors[i].y > ymax) ymax = mapvectors[i].y
        }

        var mapcellwidth = 32
        var mapcellheight = 32
        var mapxcells = Math.ceil(xmax / mapcellwidth)
        var mapycells = Math.ceil(ymax / mapcellheight)

        autoupdate()
        draw()

        for (var i = 0; i < mapvectors.length; i++) mapvectors[i].index = i
        for (var i = 0; i < maplinedefs.length; i++) maplinedefs[i].index = i
        for (var i = 0; i < mapnavs.length; i++) mapnavs[i].index = i
        for (var i = 0; i < mapsubsectors.length; i++) mapsubsectors[i].index = i

        var mapdata = '------ map ------\n' + mapcellwidth + ':' + mapcellheight + ':' + mapxcells + ':' + mapycells + '\n'

        mapdata += '------ vec ------\n'
        for (var i = 0; i < mapvectors.length; i++) mapdata += mapvectors[i].x + ':' + mapvectors[i].y + '\n'
        mapdata += '------ lnd ------\n'
        for (var i = 0; i < maplinedefs.length; i++) mapdata += maplinedefs[i].utex + ':' + maplinedefs[i].mtex + ':' + maplinedefs[i].ltex + ':' + maplinedefs[i].start.index + ':' + maplinedefs[i].end.index + '\n'
        mapdata += '------ sub ------\n'
        for (var i = 0; i < mapsubsectors.length; i++) {
          var substr = '' + mapsubsectors[i].vecs.length
          for (var z = 0; z < mapsubsectors[i].vecs.length; z++) substr += ':' + mapsubsectors[i].vecs[z].index
          mapdata += substr + '\n'
        }
        mapdata += '------ sec ------\n'
        for (var i = 0; i < mapsectors.length; i++) {
          var secstr =
            mapsectors[i].type +
            ':' +
            mapsectors[i].ftex +
            ':' +
            mapsectors[i].ctex +
            ':' +
            mapsectors[i].fheight +
            ':' +
            mapsectors[i].cheight +
            ':' +
            mapsectors[i].lines.length +
            ':' +
            mapsectors[i].portals.length +
            ':' +
            mapsectors[i].subs.length

          for (var z = 0; z < mapsectors[i].lines.length; z++) secstr += ':' + mapsectors[i].lines[z].index
          for (var z = 0; z < mapsectors[i].portals.length; z++) secstr += ':' + mapsectors[i].portals[z].index
          for (var z = 0; z < mapsectors[i].subs.length; z++) secstr += ':' + mapsectors[i].subs[z].index
          mapdata += secstr + '\n'
        }
        mapdata += '------ nav ------\n'
        for (var i = 0; i < mapnavs.length; i++) {
          if (mapnavs[i].type == 0) mapdata += mapnavs[i].type + ':' + mapnavs[i].first.index + ':' + mapnavs[i].second.index + ':' + mapnavs[i].links.length
          else mapdata += mapnavs[i].type + ':' + mapnavs[i].x + ':' + mapnavs[i].y + ':' + mapnavs[i].links.length
          for (var z = 0; z < mapnavs[i].links.length; z++) mapdata += ':' + mapnavs[i].links[z].index
          mapdata += '\n'
        }
        mapdata += '------ ent ------\n'
        for (var i = 0; i < mapentities.length; i++) mapdata += mapentities[i].reference + ':' + mapentities[i].angle + ':' + mapentities[i].x + ':' + mapentities[i].y + '\n'

        return mapdata
      }
      function loadfile() {
        mapvectors.splice(0, mapvectors.length)
        maplinedefs.splice(0, maplinedefs.length)
        mapentities.splice(0, mapentities.length)

        zoom = 1
        elementzoom.innerHTML = 'zoom = ' + zoom
        gridscale = 1
        elementgridscale.innerHTML = 'grid scale = ' + gridscale
        zgrid = 1
        elementzgrid.innerHTML = 'zgrid = ' + zgrid
        xoffset = 0
        yoffset = 0
        elementoffset.innerHTML = 'offset = ' + xoffset + ', ' + yoffset

        var d = document.getElementById('loadtext').value
        traverseitems(d)

        autoupdate()
        draw()
      }
      function traverseitems(d) {
        var v = new Array(0, 0)
        while (v[0] < d.length) {
          if (d[v[0]] == '-') {
            v[1]++
            while (d[v[0]] != '\n') v[0]++
          } else {
            var i = 0
            var values = new Array()
            values.push('')
            while (v[0] < d.length) {
              if (d[v[0]] == '\n') break
              if (d[v[0]] == ':') {
                i++
                values.push('')
              } else values[i] += d[v[0]]
              v[0]++
            }
            switch (v[1]) {
              case 1:
                break
              case 2:
                loadvec(values)
                break
              case 3:
                loadlnd(values)
                break
              case 4:
                break
              case 5:
                loadsec(values)
                break
              case 6:
                break
              case 7:
                loadent(values)
                break
            }
          }
          v[0]++
        }
      }
      function loadvec(v) {
        mapvectors.push(new vector(parseInt(v[0]), parseInt(v[1])))
      }
      function loadlnd(v) {
        maplinedefs.push(new linedef(mapvectors[parseInt(v[3])], mapvectors[parseInt(v[4])]))
        maplinedefs[maplinedefs.length - 1].utex = parseInt(v[0])
        maplinedefs[maplinedefs.length - 1].mtex = parseInt(v[1])
        maplinedefs[maplinedefs.length - 1].ltex = parseInt(v[2])
      }
      function loadsec(v) {
        var l = parseInt(v[5])
        var p = parseInt(v[6])
        var s = parseInt(v[7])
        var pos = 8

        var lines = new Array()
        for (var z = 0; z < l; z++) lines.push(maplinedefs[parseInt(v[pos + z])])
        pos += l

        var portals = new Array()
        for (var z = 0; z < p; z++) portals.push(maplinedefs[parseInt(v[pos + z])])
        pos += p

        var subs = new Array()
        for (var z = 0; z < s; z++) subs.push(mapsubsectors[parseInt(v[pos + z])])

        mapsectors.push(new sector(subs, lines, portals))
        mapsectors[mapsectors.length - 1].type = parseInt(v[0])
        mapsectors[mapsectors.length - 1].ftex = parseInt(v[1])
        mapsectors[mapsectors.length - 1].ctex = parseInt(v[2])
        mapsectors[mapsectors.length - 1].fheight = parseInt(v[3])
        mapsectors[mapsectors.length - 1].cheight = parseInt(v[4])
      }
      function loadent(v) {
        mapentities.push(new entity(parseInt(v[2]), parseInt(v[3])))
        mapentities[mapentities.length - 1].reference = parseInt(v[0])
        mapentities[mapentities.length - 1].angle = parseInt(v[1])
      }
      function toolswap() {
        xfpoint = -1
        yfpoint = -1
        xspoint = -1
        yspoint = -1
        svector = null
        veclist.splice(0, veclist.length)
        sublist.splice(0, sublist.length)
        linelist.splice(0, linelist.length)
        portallist.splice(0, portallist.length)
      }
      function tool(id) {
        if (loadopen || saveopen || resourceopen || sectoropen || modlineopen || modentityopen) return

        var child = document.getElementById('tool')
        toolswap()

        switch (id) {
          case 0:
            child.innerHTML = 'tool = magnify'
            editmode = modemagnify
            break
          case 1:
            child.innerHTML = 'tool = grid scale'
            editmode = modegridscale
            break
          case 2:
            child.innerHTML = 'tool = offset'
            editmode = modeoffset
            break
          case 3:
            child.innerHTML = 'tool = mod vector'
            editmode = modemodvector
            break
          case 4:
            child.innerHTML = 'tool = add line'
            editmode = modeaddline
            break
          case 5:
            child.innerHTML = 'tool = mod line'
            editmode = modemodline
            break
          case 8:
            child.innerHTML = 'tool = mod sec'
            editmode = modemodsector
            break
          case 9:
            child.innerHTML = 'tool = add entity'
            editmode = modeaddentity
            break
        }

        draw()
      }
      function drawtoggle(id) {
        switch (id) {
          case 0:
            drawgrid = !drawgrid
            break
          case 1:
            drawlinenormals = !drawlinenormals
            break
          case 2:
            drawlabels = !drawlabels
            break
          case 3:
            drawlinelabels = !drawlinelabels
            break
          case 4:
            drawvectors = !drawvectors
            break
          case 5:
            drawlines = !drawlines
            break
          case 6:
            drawsubsectors = !drawsubsectors
            break
          case 7:
            drawsectors = !drawsectors
            break
          case 8:
            drawnavs = !drawnavs
            break
          case 9:
            drawentities = !drawentities
            break
        }

        draw()
      }
    </script>
  </head>
  <body onload="load()">
    <!-- load/save text -->
    <div id="loadsave" style="position: fixed; top: 1px; left: 1px; width: 75%; height: 65%"></div>
    <!-- canvas -->
    <div style="background-color: rgb(128, 128, 128); height: 85%">
      <canvas id="view" style="float: left" width="640" height="360"></canvas>
      <div style="background-color: rgb(200, 200, 200); padding-left: 1px; height: 100%; overflow: auto; white-space: nowrap">
        <div id="tool">tool =</div>
        <br />
        <div id="offset">offset = 0, 0</div>
        <div id="zoom">zoom = 1</div>
        <div id="gridscale">grid scale = 1</div>
        <div id="zgrid">zgrid = 1</div>
        <br />
        <div id="cvec">vectors = 0</div>
        <div id="cline">linedefs = 0</div>
        <div id="csub">sub sectors = 0</div>
        <div id="csec">sectors = 0</div>
        <div id="cnav">navs = 0</div>
        <div id="cent">entities = 0</div>
        <br />
        <div id="editinfo"></div>
      </div>
    </div>
    <div style="clear: left; background-color: rgb(220, 220, 220); height: 15%; overflow: auto; white-space: nowrap">
      <!-- tools -->
      <button type="button" onclick="drawtoggle(0)">grid</button>
      <button type="button" onclick="drawtoggle(1)">normals</button>
      <button type="button" onclick="drawtoggle(2)">labels</button>
      <button type="button" onclick="drawtoggle(3)">line labels</button>
      <button type="button" onclick="drawtoggle(4)">vectors</button>
      <button type="button" onclick="drawtoggle(5)">lines</button>
      <button type="button" onclick="drawtoggle(6)">sub sectors</button>
      <button type="button" onclick="drawtoggle(7)">sectors</button>
      <button type="button" onclick="drawtoggle(8)">navs</button>
      <button type="button" onclick="drawtoggle(9)">entities</button>
      <br />
      <button type="button" onclick="tool(4)">add line</button>
      <button type="button" onclick="tool(9)">add entity</button>
      <button type="button">------------</button>
      <button type="button" onclick="tool(3)">mod vector</button>
      <button type="button" onclick="tool(5)">mod line</button>
      <button type="button" onclick="tool(8)">mod sec</button>
      <br />
      <button type="button" onclick="tool(0)">magnify</button>
      <button type="button" onclick="tool(1)">grid scale</button>
      <button type="button" onclick="tool(2)">offset</button>
      <br />
      <!-- load/save buttons -->
      <button type="button" onclick="loadtext()">load</button>
      <button type="button" onclick="savetext()">save</button>
    </div>
  </body>
</html>
